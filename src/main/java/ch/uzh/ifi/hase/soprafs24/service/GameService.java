package ch.uzh.ifi.hase.soprafs24.service;

import ch.uzh.ifi.hase.soprafs24.entity.Match;
import ch.uzh.ifi.hase.soprafs24.entity.MatchPlayer;
import ch.uzh.ifi.hase.soprafs24.entity.MatchStats;
import ch.uzh.ifi.hase.soprafs24.entity.User;
import ch.uzh.ifi.hase.soprafs24.model.NewDeckResponse;
import ch.uzh.ifi.hase.soprafs24.repository.MatchPlayerRepository;
import ch.uzh.ifi.hase.soprafs24.repository.MatchRepository;
import ch.uzh.ifi.hase.soprafs24.repository.MatchStatsRepository;
import ch.uzh.ifi.hase.soprafs24.repository.UserRepository;
import ch.uzh.ifi.hase.soprafs24.rest.dto.PlayerMatchInformationDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.server.ResponseStatusException;
import reactor.core.publisher.Mono;

import java.util.ArrayList;
import java.util.List;

/**
 * Game Service
 * This class is the "worker" and responsible for all functionality related to
 * currently ongoing games, e.g. updating the player's scores, requesting information
 * from the deck of cards API, etc.
 * (e.g., it creates, modifies, deletes, finds). The result will be passed back
 * to the caller.
 */
@Service
@Transactional
public class GameService {
    private final MatchRepository matchRepository;
    private final UserService userService;
    private final UserRepository userRepository;
    private final MatchPlayerRepository matchPlayerRepository;
    private final MatchStatsRepository matchStatsRepository;
    private final WebClient externalApiClient;

    @Autowired
    public GameService(
            @Qualifier("matchRepository") MatchRepository matchRepository,
            UserService userService,
            @Qualifier("userRepository") UserRepository userRepository,
            @Qualifier("matchPlayerRepository") MatchPlayerRepository matchPlayerRepository,
            @Qualifier("matchStatsRepository") MatchStatsRepository matchStatsRepository,
            @Qualifier("externalApiClient") WebClient externalApiClient) {
        this.matchRepository = matchRepository;
        this.userService = userService;
        this.userRepository = userRepository;
        this.matchPlayerRepository = matchPlayerRepository;
        this.matchStatsRepository = matchStatsRepository;
        this.externalApiClient = externalApiClient;
    }

    /**
     * Gets the information generated by the deck of cards API (e.g. deck_id, success, etc.).
     * @return The information given by the deck of cards API.
     */
    public Mono<NewDeckResponse> createNewDeck() {
        return externalApiClient.get()
                .uri("/new/shuffle/?deck_count=1")
                .retrieve()
                .bodyToMono(NewDeckResponse.class);
    }

    /**
     * Gets the necessary information for a player.
     * @param token The player's token
     * @param matchId The id of the match the user is in
     * @return Information specific to a player (e.g. their current cards)
     */
    public PlayerMatchInformationDTO getPlayerMatchInformation(String token, Long matchId) {
        Match match = matchRepository.findMatchByMatchId(matchId);
        User user = userRepository.findUserByToken(token);

        if (match == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Match not found");
        }
        if (user == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Invalid token");
        }

        MatchPlayer matchPlayer = matchPlayerRepository.findMatchPlayerByUser(user);

        if (matchPlayer == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Match not found");
        }

        List<String> matchPlayers = new ArrayList<>();
        matchPlayers.add(null);
        matchPlayers.add(null);
        matchPlayers.add(null);
        matchPlayers.add(null);

        List<MatchPlayer> matchPlayerList = match.getMatchPlayers();

        List<User> usersInMatch = new ArrayList<>();
        usersInMatch.add(match.getPlayer1());
        usersInMatch.add(match.getPlayer2());
        usersInMatch.add(match.getPlayer3());
        usersInMatch.add(match.getPlayer4());

        for (MatchPlayer player : matchPlayerList) {
            User matchPlayerUser = player.getPlayerId();

            int slot = 0;

            for (User userInMatch : usersInMatch) {
                if (userInMatch == matchPlayerUser) {
                    break;
                }
                slot++;
            }

            matchPlayers.set(slot, matchPlayerUser.getUsername());
        }

        System.out.println(matchPlayers);

        PlayerMatchInformationDTO dto = new PlayerMatchInformationDTO();
        dto.setMatchId(match.getMatchId());
        dto.setHost(match.getHost());
        dto.setMatchPlayers(matchPlayers);
        dto.setAiPlayers(match.getAiPlayers());
        dto.setLength(match.getLength());
        dto.setStarted(true);

        return dto;
    }

    /**
     * Starts the match when the host clicks on the start button
     * @param matchId The match's id
     * @param token The token of the player sending the request
     */
    public void startMatch(Long matchId, String token) {
        User givenUser = userRepository.findUserByToken(token);
        Match givenMatch = matchRepository.findMatchByMatchId(matchId);

        if (givenUser == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found");
        }

        if (givenMatch == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Match not found");
        }

        if (!givenUser.getUsername().equals(givenMatch.getHost())) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Only the host can start the match");
        }

        List<MatchPlayer> matchPlayers = givenMatch.getMatchPlayers();

        for (MatchPlayer matchPlayer : matchPlayers) {
            MatchStats matchStats = new MatchStats();
            matchStats.setMatch(givenMatch);
            matchStats.setPlayer(matchPlayer.getPlayerId());
            matchStats.setMalusPoints(0);
            matchStats.setPerfectGames(0);
            matchStats.setShotTheMoonCount(0);

            matchStatsRepository.save(matchStats);
            matchStatsRepository.flush();
        }

        Mono<NewDeckResponse> newDeckResponseMono = createNewDeck();

        // Is executed, when the response from the deck of cards API arrives
        newDeckResponseMono.subscribe(response -> {
            System.out.println(response.getDeck_id());
            givenMatch.setDeckId(response.getDeck_id());
            matchRepository.save(givenMatch);
            matchRepository.flush();
        });
    }
}
